<!DOCTYPE html><html> <head><meta name="robots" content="noindex"><title>Extension Messaging frame</title><script type="module">const u=/firefox/i.test(navigator.userAgent),c=typeof chrome<"u"?chrome:typeof browser<"u"?browser:null,o={};parent===window?document.body.innerHTML="<p>This page is intended to be embedded for internal communication.</p>":parent.postMessage({type:"from-page",method:"init"},"*");const a=(()=>{const e=new URLSearchParams(location.search);return{extID:e.get("extID"),origin:e.get("origin")}})(),g={isInstalled:async e=>{if(u)return console.warn("Using Firefox bridge, checking if bridge is ready"),!!window.__cors_unlocker_ready__;if(!(!!c&&!!c.runtime)){if(e&&e.throw)throw{type:"not-installed",message:"browser extension API not available"};return!1}if(!a.extID){if(e&&e.throw)throw{type:"config-error",message:"extID not provided"};return!1}try{const r=await d("ping",{},2e3);return!!r&&r.success===!0}catch{if(e&&e.throw)throw{type:"not-installed",message:`extension with ID ${a.extID} not installed or not responding`};return!1}},enable:async(e={})=>{const t=await d("getRule");if(t&&!t.disabled){if(!e||typeof e.credentials>"u")return{enable:!0,credentials:t.credentials};if(t.credentials===e.credentials)return{enabled:!0,credentials:t.credentials}}const r=a.origin;if(!t||t.disabled||!t.credentials){let s=`Current page("${r}") is requesting to enable CORS`;if(s+=e.credentials?" **with credentials**.":".",s+=e.reason?`

Message from current Page:
${e.reason}

`:`

`,s+="Please only enable CORS with credentials if you trust the current page. Do you want to continue?",!confirm(s))throw{type:"user-cancel",message:"User canceled"}}return d("enable",e)}};window.addEventListener("message",async e=>{const t=e.data;if(!t)return;if(t.type==="from-cs"&&e.source===window){const n=o[t.id];if(!n)return;const[i,l]=n;return t.error?l(t.error):i(t.data)}if(!y(t)||t.type!=="from-npm")return;const{method:r,payload:s}=t;try{const n=g[r];if(r!=="isInstalled"&&await g.isInstalled({throw:!0}),!a.extID||!a.origin)throw{type:"config-error",message:"extID or origin not provided"};try{new URL(a.origin)}catch{throw{type:"invalid-origin",message:"invalid origin"}}const i=n?await n(s):await d(r,s);f({id:t.id,type:"response",data:i})}catch(n){f({id:t.id,type:"response",error:n&&typeof n=="object"?n:{message:n,type:"inner-error"}})}});function d(e,t,r){return u?w(e,t,r):new Promise((s,n)=>{c.runtime.sendMessage(a.extID,{method:e,payload:{...t,origin:a.origin}},i=>{if(i&&typeof i=="object"&&i.__mozWebExtensionPolyfillReject__)try{return n(JSON.parse(i.message))}catch{return n(i.message)}if(c.runtime.lastError)return n({type:"communication-failed",message:c.runtime.lastError.message||"Connection failed"});s(i)}),r&&setTimeout(()=>{n({type:"timeout",message:`Message "${e}" timed out after ${r}ms`})},r)})}function w(e,t,r){return new Promise((s,n)=>{const i=Math.random().toString(36).substring(2,15);o[i]=[s,n],window.postMessage({type:"to-cs",id:i,method:e,payload:{...t,origin:a.origin}},"*"),r&&setTimeout(()=>{if(!o[i])return;const[l,m]=o[i];delete o[i],m({type:"timeout",message:`Message "${e}" timed out after ${r}ms`})},r)})}function y(e){return e&&e.type&&e.id&&e.method}function f(e){parent.postMessage(e,"*")}</script></head> </html>